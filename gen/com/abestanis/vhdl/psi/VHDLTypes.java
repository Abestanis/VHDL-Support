// This is a generated file. Not intended for manual editing.
package com.abestanis.vhdl.psi;

import com.intellij.psi.tree.IElementType;
import com.intellij.psi.PsiElement;
import com.intellij.lang.ASTNode;
import com.abestanis.vhdl.psi.impl.*;

public interface VHDLTypes {

  IElementType ABSTRACT_LITERAL = new VHDLElementType("ABSTRACT_LITERAL");
  IElementType ACCESS_TYPE_DEFINITION = new VHDLElementType("ACCESS_TYPE_DEFINITION");
  IElementType ACTUAL_DESIGNATOR = new VHDLElementType("ACTUAL_DESIGNATOR");
  IElementType ACTUAL_PARAMETER_PART = new VHDLElementType("ACTUAL_PARAMETER_PART");
  IElementType ACTUAL_PART = new VHDLElementType("ACTUAL_PART");
  IElementType ADDING_OPERATOR = new VHDLElementType("ADDING_OPERATOR");
  IElementType AGGREGATE = new VHDLElementType("AGGREGATE");
  IElementType ALIAS_DECLARATION = new VHDLElementType("ALIAS_DECLARATION");
  IElementType ALIAS_DESIGNATOR = new VHDLElementType("ALIAS_DESIGNATOR");
  IElementType ALLOCATOR = new VHDLElementType("ALLOCATOR");
  IElementType ARCHITECTURE_BODY = new VHDLElementType("ARCHITECTURE_BODY");
  IElementType ARCHITECTURE_DECLARATIVE_PART = new VHDLElementType("ARCHITECTURE_DECLARATIVE_PART");
  IElementType ARCHITECTURE_STATEMENT_PART = new VHDLElementType("ARCHITECTURE_STATEMENT_PART");
  IElementType ARRAY_TYPE_DEFINITION = new VHDLElementType("ARRAY_TYPE_DEFINITION");
  IElementType ASSERTION = new VHDLElementType("ASSERTION");
  IElementType ASSERTION_STATEMENT = new VHDLElementType("ASSERTION_STATEMENT");
  IElementType ASSOCIATION_ELEMENT = new VHDLElementType("ASSOCIATION_ELEMENT");
  IElementType ASSOCIATION_LIST = new VHDLElementType("ASSOCIATION_LIST");
  IElementType ATTRIBUTE_DECLARATION = new VHDLElementType("ATTRIBUTE_DECLARATION");
  IElementType ATTRIBUTE_DESIGNATOR = new VHDLElementType("ATTRIBUTE_DESIGNATOR");
  IElementType ATTRIBUTE_NAME = new VHDLElementType("ATTRIBUTE_NAME");
  IElementType ATTRIBUTE_NAME_ = new VHDLElementType("ATTRIBUTE_NAME_");
  IElementType ATTRIBUTE_SPECIFICATION = new VHDLElementType("ATTRIBUTE_SPECIFICATION");
  IElementType BINDING_INDICATION = new VHDLElementType("BINDING_INDICATION");
  IElementType BLOCK_CONFIGURATION = new VHDLElementType("BLOCK_CONFIGURATION");
  IElementType BLOCK_DECLARATIVE_ITEM = new VHDLElementType("BLOCK_DECLARATIVE_ITEM");
  IElementType BLOCK_DECLARATIVE_PART = new VHDLElementType("BLOCK_DECLARATIVE_PART");
  IElementType BLOCK_HEADER = new VHDLElementType("BLOCK_HEADER");
  IElementType BLOCK_SPECIFICATION = new VHDLElementType("BLOCK_SPECIFICATION");
  IElementType BLOCK_STATEMENT = new VHDLElementType("BLOCK_STATEMENT");
  IElementType BLOCK_STATEMENT_PART = new VHDLElementType("BLOCK_STATEMENT_PART");
  IElementType CASE_STATEMENT = new VHDLElementType("CASE_STATEMENT");
  IElementType CASE_STATEMENT_ALTERNATIVE = new VHDLElementType("CASE_STATEMENT_ALTERNATIVE");
  IElementType CHOICE = new VHDLElementType("CHOICE");
  IElementType CHOICES = new VHDLElementType("CHOICES");
  IElementType COMPONENT_CONFIGURATION = new VHDLElementType("COMPONENT_CONFIGURATION");
  IElementType COMPONENT_DECLARATION = new VHDLElementType("COMPONENT_DECLARATION");
  IElementType COMPONENT_INSTANTIATION_STATEMENT = new VHDLElementType("COMPONENT_INSTANTIATION_STATEMENT");
  IElementType COMPONENT_SPECIFICATION = new VHDLElementType("COMPONENT_SPECIFICATION");
  IElementType COMPOSITE_TYPE_DEFINITION = new VHDLElementType("COMPOSITE_TYPE_DEFINITION");
  IElementType CONCURRENT_ASSERTION_STATEMENT = new VHDLElementType("CONCURRENT_ASSERTION_STATEMENT");
  IElementType CONCURRENT_PROCEDURE_CALL_STATEMENT = new VHDLElementType("CONCURRENT_PROCEDURE_CALL_STATEMENT");
  IElementType CONCURRENT_SIGNAL_ASSIGNMENT_STATEMENT = new VHDLElementType("CONCURRENT_SIGNAL_ASSIGNMENT_STATEMENT");
  IElementType CONCURRENT_STATEMENT = new VHDLElementType("CONCURRENT_STATEMENT");
  IElementType CONDITION = new VHDLElementType("CONDITION");
  IElementType CONDITIONAL_SIGNAL_ASSIGNMENT = new VHDLElementType("CONDITIONAL_SIGNAL_ASSIGNMENT");
  IElementType CONDITIONAL_WAVEFORMS = new VHDLElementType("CONDITIONAL_WAVEFORMS");
  IElementType CONDITION_CLAUSE = new VHDLElementType("CONDITION_CLAUSE");
  IElementType CONFIGURATION_DECLARATION = new VHDLElementType("CONFIGURATION_DECLARATION");
  IElementType CONFIGURATION_DECLARATIVE_ITEM = new VHDLElementType("CONFIGURATION_DECLARATIVE_ITEM");
  IElementType CONFIGURATION_DECLARATIVE_PART = new VHDLElementType("CONFIGURATION_DECLARATIVE_PART");
  IElementType CONFIGURATION_ITEM = new VHDLElementType("CONFIGURATION_ITEM");
  IElementType CONFIGURATION_SPECIFICATION = new VHDLElementType("CONFIGURATION_SPECIFICATION");
  IElementType CONSTANT_DECLARATION = new VHDLElementType("CONSTANT_DECLARATION");
  IElementType CONSTRAINED_ARRAY_DEFINITION = new VHDLElementType("CONSTRAINED_ARRAY_DEFINITION");
  IElementType CONSTRAINT = new VHDLElementType("CONSTRAINT");
  IElementType CONTEXT_CLAUSE = new VHDLElementType("CONTEXT_CLAUSE");
  IElementType CONTEXT_ITEM = new VHDLElementType("CONTEXT_ITEM");
  IElementType DELAY_MECHANISM = new VHDLElementType("DELAY_MECHANISM");
  IElementType DESIGNATOR = new VHDLElementType("DESIGNATOR");
  IElementType DESIGN_UNIT = new VHDLElementType("DESIGN_UNIT");
  IElementType DIRECTION = new VHDLElementType("DIRECTION");
  IElementType DISCONNECTION_SPECIFICATION = new VHDLElementType("DISCONNECTION_SPECIFICATION");
  IElementType DISCRETE_RANGE = new VHDLElementType("DISCRETE_RANGE");
  IElementType ELEMENT_ASSOCIATION = new VHDLElementType("ELEMENT_ASSOCIATION");
  IElementType ELEMENT_DECLARATION = new VHDLElementType("ELEMENT_DECLARATION");
  IElementType ELEMENT_SUBTYPE_DEFINITION = new VHDLElementType("ELEMENT_SUBTYPE_DEFINITION");
  IElementType ENCODED_STRING_LITERAL = new VHDLElementType("ENCODED_STRING_LITERAL");
  IElementType ENTITY_ASPECT = new VHDLElementType("ENTITY_ASPECT");
  IElementType ENTITY_CLASS = new VHDLElementType("ENTITY_CLASS");
  IElementType ENTITY_CLASS_ENTRY = new VHDLElementType("ENTITY_CLASS_ENTRY");
  IElementType ENTITY_CLASS_ENTRY_LIST = new VHDLElementType("ENTITY_CLASS_ENTRY_LIST");
  IElementType ENTITY_DECLARATION = new VHDLElementType("ENTITY_DECLARATION");
  IElementType ENTITY_DECLARATIVE_ITEM = new VHDLElementType("ENTITY_DECLARATIVE_ITEM");
  IElementType ENTITY_DECLARATIVE_PART = new VHDLElementType("ENTITY_DECLARATIVE_PART");
  IElementType ENTITY_DESIGNATOR = new VHDLElementType("ENTITY_DESIGNATOR");
  IElementType ENTITY_HEADER = new VHDLElementType("ENTITY_HEADER");
  IElementType ENTITY_NAME_LIST = new VHDLElementType("ENTITY_NAME_LIST");
  IElementType ENTITY_SPECIFICATION = new VHDLElementType("ENTITY_SPECIFICATION");
  IElementType ENTITY_STATEMENT = new VHDLElementType("ENTITY_STATEMENT");
  IElementType ENTITY_STATEMENT_PART = new VHDLElementType("ENTITY_STATEMENT_PART");
  IElementType ENTITY_TAG = new VHDLElementType("ENTITY_TAG");
  IElementType ENUMERATION_LITERAL = new VHDLElementType("ENUMERATION_LITERAL");
  IElementType ENUMERATION_TYPE_DEFINITION = new VHDLElementType("ENUMERATION_TYPE_DEFINITION");
  IElementType EXIT_STATEMENT = new VHDLElementType("EXIT_STATEMENT");
  IElementType EXPRESSION = new VHDLElementType("EXPRESSION");
  IElementType FACTOR = new VHDLElementType("FACTOR");
  IElementType FILE_DECLARATION = new VHDLElementType("FILE_DECLARATION");
  IElementType FILE_LOGICAL_NAME = new VHDLElementType("FILE_LOGICAL_NAME");
  IElementType FILE_OPEN_INFORMATION = new VHDLElementType("FILE_OPEN_INFORMATION");
  IElementType FILE_TYPE_DEFINITION = new VHDLElementType("FILE_TYPE_DEFINITION");
  IElementType FLOATING_TYPE_DEFINITION = new VHDLElementType("FLOATING_TYPE_DEFINITION");
  IElementType FORMAL_DESIGNATOR = new VHDLElementType("FORMAL_DESIGNATOR");
  IElementType FORMAL_PARAMETER_LIST = new VHDLElementType("FORMAL_PARAMETER_LIST");
  IElementType FORMAL_PART = new VHDLElementType("FORMAL_PART");
  IElementType FULL_TYPE_DECLARATION = new VHDLElementType("FULL_TYPE_DECLARATION");
  IElementType FUNCTION_CALL = new VHDLElementType("FUNCTION_CALL");
  IElementType FUNCTION_CALL_PARAMETER = new VHDLElementType("FUNCTION_CALL_PARAMETER");
  IElementType GENERATE_STATEMENT = new VHDLElementType("GENERATE_STATEMENT");
  IElementType GENERATION_SCHEME = new VHDLElementType("GENERATION_SCHEME");
  IElementType GENERIC_CLAUSE = new VHDLElementType("GENERIC_CLAUSE");
  IElementType GENERIC_LIST = new VHDLElementType("GENERIC_LIST");
  IElementType GENERIC_MAP_ASPECT = new VHDLElementType("GENERIC_MAP_ASPECT");
  IElementType GROUP_CONSTITUENT = new VHDLElementType("GROUP_CONSTITUENT");
  IElementType GROUP_CONSTITUENT_LIST = new VHDLElementType("GROUP_CONSTITUENT_LIST");
  IElementType GROUP_DECLARATION = new VHDLElementType("GROUP_DECLARATION");
  IElementType GROUP_TEMPLATE_DECLARATION = new VHDLElementType("GROUP_TEMPLATE_DECLARATION");
  IElementType GUARDED_SIGNAL_SPECIFICATION = new VHDLElementType("GUARDED_SIGNAL_SPECIFICATION");
  IElementType IDENTIFIER = new VHDLElementType("IDENTIFIER");
  IElementType IDENTIFIER_LIST = new VHDLElementType("IDENTIFIER_LIST");
  IElementType IF_STATEMENT = new VHDLElementType("IF_STATEMENT");
  IElementType INCOMPLETE_TYPE_DECLARATION = new VHDLElementType("INCOMPLETE_TYPE_DECLARATION");
  IElementType INDEXED_NAME = new VHDLElementType("INDEXED_NAME");
  IElementType INDEXED_NAME_FUNCTION_CALL = new VHDLElementType("INDEXED_NAME_FUNCTION_CALL");
  IElementType INDEX_CONSTRAINT = new VHDLElementType("INDEX_CONSTRAINT");
  IElementType INDEX_SPECIFICATION = new VHDLElementType("INDEX_SPECIFICATION");
  IElementType INDEX_SUBTYPE_DEFINITION = new VHDLElementType("INDEX_SUBTYPE_DEFINITION");
  IElementType INSTANTIATED_UNIT = new VHDLElementType("INSTANTIATED_UNIT");
  IElementType INSTANTIATION_LIST = new VHDLElementType("INSTANTIATION_LIST");
  IElementType INTEGER_TYPE_DEFINITION = new VHDLElementType("INTEGER_TYPE_DEFINITION");
  IElementType INTERFACE_CONSTANT_DECLARATION = new VHDLElementType("INTERFACE_CONSTANT_DECLARATION");
  IElementType INTERFACE_DECLARATION = new VHDLElementType("INTERFACE_DECLARATION");
  IElementType INTERFACE_ELEMENT = new VHDLElementType("INTERFACE_ELEMENT");
  IElementType INTERFACE_FILE_DECLARATION = new VHDLElementType("INTERFACE_FILE_DECLARATION");
  IElementType INTERFACE_LIST = new VHDLElementType("INTERFACE_LIST");
  IElementType INTERFACE_SIGNAL_DECLARATION = new VHDLElementType("INTERFACE_SIGNAL_DECLARATION");
  IElementType INTERFACE_VARIABLE_DECLARATION = new VHDLElementType("INTERFACE_VARIABLE_DECLARATION");
  IElementType ITERATION_SCHEME = new VHDLElementType("ITERATION_SCHEME");
  IElementType LABEL_ = new VHDLElementType("LABEL_");
  IElementType LIBRARY_CLAUSE = new VHDLElementType("LIBRARY_CLAUSE");
  IElementType LIBRARY_UNIT = new VHDLElementType("LIBRARY_UNIT");
  IElementType LITERAL_ = new VHDLElementType("LITERAL_");
  IElementType LOGICAL_NAME = new VHDLElementType("LOGICAL_NAME");
  IElementType LOGICAL_NAME_LIST = new VHDLElementType("LOGICAL_NAME_LIST");
  IElementType LOOP_STATEMENT = new VHDLElementType("LOOP_STATEMENT");
  IElementType MODE = new VHDLElementType("MODE");
  IElementType MULTIPLYING_OPERATOR = new VHDLElementType("MULTIPLYING_OPERATOR");
  IElementType NAME_ = new VHDLElementType("NAME_");
  IElementType NEXT_STATEMENT = new VHDLElementType("NEXT_STATEMENT");
  IElementType NULL_STATEMENT = new VHDLElementType("NULL_STATEMENT");
  IElementType NUMERIC_LITERAL = new VHDLElementType("NUMERIC_LITERAL");
  IElementType OPERATOR_SYMBOL = new VHDLElementType("OPERATOR_SYMBOL");
  IElementType OPTIONS = new VHDLElementType("OPTIONS");
  IElementType PACKAGE_BODY = new VHDLElementType("PACKAGE_BODY");
  IElementType PACKAGE_BODY_DECLARATIVE_ITEM = new VHDLElementType("PACKAGE_BODY_DECLARATIVE_ITEM");
  IElementType PACKAGE_BODY_DECLARATIVE_PART = new VHDLElementType("PACKAGE_BODY_DECLARATIVE_PART");
  IElementType PACKAGE_DECLARATION = new VHDLElementType("PACKAGE_DECLARATION");
  IElementType PACKAGE_DECLARATIVE_ITEM = new VHDLElementType("PACKAGE_DECLARATIVE_ITEM");
  IElementType PACKAGE_DECLARATIVE_PART = new VHDLElementType("PACKAGE_DECLARATIVE_PART");
  IElementType PARAMETER_SPECIFICATION = new VHDLElementType("PARAMETER_SPECIFICATION");
  IElementType PHYSICAL_LITERAL = new VHDLElementType("PHYSICAL_LITERAL");
  IElementType PHYSICAL_TYPE_DEFINITION = new VHDLElementType("PHYSICAL_TYPE_DEFINITION");
  IElementType PORT_CLAUSE = new VHDLElementType("PORT_CLAUSE");
  IElementType PORT_LIST = new VHDLElementType("PORT_LIST");
  IElementType PORT_MAP_ASPECT = new VHDLElementType("PORT_MAP_ASPECT");
  IElementType PRIMARY = new VHDLElementType("PRIMARY");
  IElementType PRIMARY_UNIT = new VHDLElementType("PRIMARY_UNIT");
  IElementType PRIMARY_UNIT_DECLARATION = new VHDLElementType("PRIMARY_UNIT_DECLARATION");
  IElementType PROCEDURE_CALL = new VHDLElementType("PROCEDURE_CALL");
  IElementType PROCEDURE_CALL_STATEMENT = new VHDLElementType("PROCEDURE_CALL_STATEMENT");
  IElementType PROCESS_DECLARATIVE_ITEM = new VHDLElementType("PROCESS_DECLARATIVE_ITEM");
  IElementType PROCESS_DECLARATIVE_PART = new VHDLElementType("PROCESS_DECLARATIVE_PART");
  IElementType PROCESS_STATEMENT = new VHDLElementType("PROCESS_STATEMENT");
  IElementType PROCESS_STATEMENT_PART = new VHDLElementType("PROCESS_STATEMENT_PART");
  IElementType QUALIFIED_EXPRESSION = new VHDLElementType("QUALIFIED_EXPRESSION");
  IElementType RANGE_ = new VHDLElementType("RANGE_");
  IElementType RANGE_CONSTRAINT = new VHDLElementType("RANGE_CONSTRAINT");
  IElementType RECORD_TYPE_DEFINITION = new VHDLElementType("RECORD_TYPE_DEFINITION");
  IElementType RELATION = new VHDLElementType("RELATION");
  IElementType RELATIONAL_OPERATOR = new VHDLElementType("RELATIONAL_OPERATOR");
  IElementType REPORT_STATEMENT = new VHDLElementType("REPORT_STATEMENT");
  IElementType RETURN_STATEMENT = new VHDLElementType("RETURN_STATEMENT");
  IElementType SCALAR_TYPE_DEFINITION = new VHDLElementType("SCALAR_TYPE_DEFINITION");
  IElementType SECONDARY_UNIT = new VHDLElementType("SECONDARY_UNIT");
  IElementType SECONDARY_UNIT_DECLARATION = new VHDLElementType("SECONDARY_UNIT_DECLARATION");
  IElementType SELECTED_NAME = new VHDLElementType("SELECTED_NAME");
  IElementType SELECTED_SIGNAL_ASSIGNMENT = new VHDLElementType("SELECTED_SIGNAL_ASSIGNMENT");
  IElementType SELECTED_WAVEFORMS = new VHDLElementType("SELECTED_WAVEFORMS");
  IElementType SENSITIVITY_CLAUSE = new VHDLElementType("SENSITIVITY_CLAUSE");
  IElementType SENSITIVITY_LIST = new VHDLElementType("SENSITIVITY_LIST");
  IElementType SEQUENCE_OF_STATEMENTS = new VHDLElementType("SEQUENCE_OF_STATEMENTS");
  IElementType SEQUENTIAL_STATEMENT = new VHDLElementType("SEQUENTIAL_STATEMENT");
  IElementType SHIFT_EXPRESSION = new VHDLElementType("SHIFT_EXPRESSION");
  IElementType SHIFT_OPERATOR = new VHDLElementType("SHIFT_OPERATOR");
  IElementType SIGN = new VHDLElementType("SIGN");
  IElementType SIGNAL_ASSIGNMENT_STATEMENT = new VHDLElementType("SIGNAL_ASSIGNMENT_STATEMENT");
  IElementType SIGNAL_DECLARATION = new VHDLElementType("SIGNAL_DECLARATION");
  IElementType SIGNAL_KIND = new VHDLElementType("SIGNAL_KIND");
  IElementType SIGNAL_LIST = new VHDLElementType("SIGNAL_LIST");
  IElementType SIGNATURE = new VHDLElementType("SIGNATURE");
  IElementType SIMPLE_EXPRESSION = new VHDLElementType("SIMPLE_EXPRESSION");
  IElementType SIMPLE_NAME = new VHDLElementType("SIMPLE_NAME");
  IElementType SLICE_NAME = new VHDLElementType("SLICE_NAME");
  IElementType SLICE_NAME_FUNCTION_CALL = new VHDLElementType("SLICE_NAME_FUNCTION_CALL");
  IElementType SUBPROGRAM_BODY = new VHDLElementType("SUBPROGRAM_BODY");
  IElementType SUBPROGRAM_DECLARATION = new VHDLElementType("SUBPROGRAM_DECLARATION");
  IElementType SUBPROGRAM_DECLARATIVE_ITEM = new VHDLElementType("SUBPROGRAM_DECLARATIVE_ITEM");
  IElementType SUBPROGRAM_DECLARATIVE_PART = new VHDLElementType("SUBPROGRAM_DECLARATIVE_PART");
  IElementType SUBPROGRAM_KIND = new VHDLElementType("SUBPROGRAM_KIND");
  IElementType SUBPROGRAM_SPECIFICATION = new VHDLElementType("SUBPROGRAM_SPECIFICATION");
  IElementType SUBPROGRAM_STATEMENT_PART = new VHDLElementType("SUBPROGRAM_STATEMENT_PART");
  IElementType SUBTYPE_DECLARATION = new VHDLElementType("SUBTYPE_DECLARATION");
  IElementType SUBTYPE_INDICATION = new VHDLElementType("SUBTYPE_INDICATION");
  IElementType SUFFIX = new VHDLElementType("SUFFIX");
  IElementType TARGET = new VHDLElementType("TARGET");
  IElementType TERM = new VHDLElementType("TERM");
  IElementType TIMEOUT_CLAUSE = new VHDLElementType("TIMEOUT_CLAUSE");
  IElementType TYPE_CONVERSION = new VHDLElementType("TYPE_CONVERSION");
  IElementType TYPE_DECLARATION = new VHDLElementType("TYPE_DECLARATION");
  IElementType TYPE_DEFINITION = new VHDLElementType("TYPE_DEFINITION");
  IElementType TYPE_MARK = new VHDLElementType("TYPE_MARK");
  IElementType UNCONSTRAINED_ARRAY_DEFINITION = new VHDLElementType("UNCONSTRAINED_ARRAY_DEFINITION");
  IElementType USE_CLAUSE = new VHDLElementType("USE_CLAUSE");
  IElementType VARIABLE_ASSIGNMENT_STATEMENT = new VHDLElementType("VARIABLE_ASSIGNMENT_STATEMENT");
  IElementType VARIABLE_DECLARATION = new VHDLElementType("VARIABLE_DECLARATION");
  IElementType WAIT_STATEMENT = new VHDLElementType("WAIT_STATEMENT");
  IElementType WAVEFORM = new VHDLElementType("WAVEFORM");
  IElementType WAVEFORM_ELEMENT = new VHDLElementType("WAVEFORM_ELEMENT");

  IElementType ABS = new VHDLTokenType("abs");
  IElementType ACCESS = new VHDLTokenType("access");
  IElementType AFTER = new VHDLTokenType("after");
  IElementType ALIAS = new VHDLTokenType("alias");
  IElementType ALL = new VHDLTokenType("all");
  IElementType AND = new VHDLTokenType("and");
  IElementType ARCHITECTURE = new VHDLTokenType("architecture");
  IElementType ARRAY = new VHDLTokenType("array");
  IElementType ASSERT = new VHDLTokenType("assert");
  IElementType ASSIGNMENT_OP = new VHDLTokenType(":=");
  IElementType ATTRIBUTE = new VHDLTokenType("attribute");
  IElementType BASED_LITERAL = new VHDLTokenType("BASED_LITERAL");
  IElementType BASIC_IDENTIFIER = new VHDLTokenType("BASIC_IDENTIFIER");
  IElementType BEGIN = new VHDLTokenType("begin");
  IElementType BIT_STRING_LITERAL = new VHDLTokenType("BIT_STRING_LITERAL");
  IElementType BLOCK = new VHDLTokenType("block");
  IElementType BODY = new VHDLTokenType("body");
  IElementType BUFFER = new VHDLTokenType("buffer");
  IElementType BUS = new VHDLTokenType("bus");
  IElementType CASE = new VHDLTokenType("case");
  IElementType CASE_THEN = new VHDLTokenType("=>");
  IElementType CHARACTER_LITERAL = new VHDLTokenType("CHARACTER_LITERAL");
  IElementType COLON = new VHDLTokenType(":");
  IElementType COMMA = new VHDLTokenType(",");
  IElementType COMMENT = new VHDLTokenType("--");
  IElementType COMPONENT = new VHDLTokenType("component");
  IElementType CONCAT = new VHDLTokenType("&");
  IElementType CONFIGURATION = new VHDLTokenType("configuration");
  IElementType CONSTANT = new VHDLTokenType("constant");
  IElementType DECIMAL_LITERAL = new VHDLTokenType("DECIMAL_LITERAL");
  IElementType DIAMOND = new VHDLTokenType("<>");
  IElementType DISCONNECT = new VHDLTokenType("disconnect");
  IElementType DIVIDE = new VHDLTokenType("/");
  IElementType DOUBLE_QUOTE = new VHDLTokenType("\"");
  IElementType DOWNTO = new VHDLTokenType("downto");
  IElementType ELSE = new VHDLTokenType("else");
  IElementType ELSIF = new VHDLTokenType("elsif");
  IElementType END = new VHDLTokenType("end");
  IElementType ENTITY = new VHDLTokenType("entity");
  IElementType EQUALS = new VHDLTokenType("=");
  IElementType EQUAL_LESS_THAN = new VHDLTokenType("<=");
  IElementType EQUAL_MORE_THAN = new VHDLTokenType(">=");
  IElementType EXIT = new VHDLTokenType("exit");
  IElementType EXTENDED_IDENTIFIER = new VHDLTokenType("EXTENDED_IDENTIFIER");
  IElementType FILE = new VHDLTokenType("file");
  IElementType FOR = new VHDLTokenType("for");
  IElementType FUNCTION = new VHDLTokenType("function");
  IElementType GENERATE = new VHDLTokenType("generate");
  IElementType GENERIC = new VHDLTokenType("generic");
  IElementType GROUP = new VHDLTokenType("group");
  IElementType GUARDED = new VHDLTokenType("guarded");
  IElementType HEX_STRING_LITERAL = new VHDLTokenType("HEX_STRING_LITERAL");
  IElementType IF = new VHDLTokenType("if");
  IElementType IMPURE = new VHDLTokenType("impure");
  IElementType IN = new VHDLTokenType("in");
  IElementType INERTIAL = new VHDLTokenType("inertial");
  IElementType INOUT = new VHDLTokenType("inout");
  IElementType IS = new VHDLTokenType("is");
  IElementType LABEL = new VHDLTokenType("label");
  IElementType LEFT_BRACE = new VHDLTokenType("{");
  IElementType LEFT_BRACK = new VHDLTokenType("[");
  IElementType LEFT_PAREN = new VHDLTokenType("(");
  IElementType LESS_THAN = new VHDLTokenType("<");
  IElementType LIBRARY = new VHDLTokenType("library");
  IElementType LINKAGE = new VHDLTokenType("linkage");
  IElementType LITERAL = new VHDLTokenType("literal");
  IElementType LOOP = new VHDLTokenType("loop");
  IElementType MAP = new VHDLTokenType("map");
  IElementType MINUS = new VHDLTokenType("-");
  IElementType MODULO = new VHDLTokenType("mod");
  IElementType MORE_THAN = new VHDLTokenType(">");
  IElementType MULTIPLY = new VHDLTokenType("*");
  IElementType NAND = new VHDLTokenType("nand");
  IElementType NEW = new VHDLTokenType("new");
  IElementType NEXT = new VHDLTokenType("next");
  IElementType NOR = new VHDLTokenType("nor");
  IElementType NOT = new VHDLTokenType("not");
  IElementType NOT_EQUAL = new VHDLTokenType("/=");
  IElementType NULL = new VHDLTokenType("null");
  IElementType OCT_STRING_LITERAL = new VHDLTokenType("OCT_STRING_LITERAL");
  IElementType OF = new VHDLTokenType("of");
  IElementType ON = new VHDLTokenType("on");
  IElementType OPEN = new VHDLTokenType("open");
  IElementType OR = new VHDLTokenType("or");
  IElementType OTHERS = new VHDLTokenType("others");
  IElementType OUT = new VHDLTokenType("out");
  IElementType PACKAGE = new VHDLTokenType("package");
  IElementType PLUS = new VHDLTokenType("+");
  IElementType POINT = new VHDLTokenType(".");
  IElementType PORT = new VHDLTokenType("port");
  IElementType POSTPONED = new VHDLTokenType("postponed");
  IElementType POW = new VHDLTokenType("**");
  IElementType PROCEDURE = new VHDLTokenType("procedure");
  IElementType PROCESS = new VHDLTokenType("process");
  IElementType PURE = new VHDLTokenType("pure");
  IElementType RANGE = new VHDLTokenType("range");
  IElementType RECORD = new VHDLTokenType("record");
  IElementType REGISTER = new VHDLTokenType("register");
  IElementType REJECT = new VHDLTokenType("reject");
  IElementType REMAINDER = new VHDLTokenType("rem");
  IElementType REPORT = new VHDLTokenType("report");
  IElementType RETURN = new VHDLTokenType("return");
  IElementType RIGHT_BRACE = new VHDLTokenType("}");
  IElementType RIGHT_BRACK = new VHDLTokenType("]");
  IElementType RIGHT_PAREN = new VHDLTokenType(")");
  IElementType ROTATE_LEFT = new VHDLTokenType("rol");
  IElementType ROTATE_RIGHT = new VHDLTokenType("ror");
  IElementType SELECT = new VHDLTokenType("select");
  IElementType SEMICOLON = new VHDLTokenType(";");
  IElementType SEVERITY = new VHDLTokenType("severity");
  IElementType SHARED = new VHDLTokenType("shared");
  IElementType SHIFT_LEFT = new VHDLTokenType("sll");
  IElementType SHIFT_LEFT_A = new VHDLTokenType("sla");
  IElementType SHIFT_RIGHT = new VHDLTokenType("srl");
  IElementType SHIFT_RIGHT_A = new VHDLTokenType("sra");
  IElementType SIGNAL = new VHDLTokenType("signal");
  IElementType SINGLE_QUOTE = new VHDLTokenType("'");
  IElementType STRING_LITERAL = new VHDLTokenType("STRING_LITERAL");
  IElementType SUBTYPE = new VHDLTokenType("subtype");
  IElementType THEN = new VHDLTokenType("then");
  IElementType TO = new VHDLTokenType("to");
  IElementType TRANSPORT = new VHDLTokenType("transport");
  IElementType TYPE = new VHDLTokenType("type");
  IElementType UNAFFECTED = new VHDLTokenType("unaffected");
  IElementType UNITS = new VHDLTokenType("units");
  IElementType UNTIL = new VHDLTokenType("until");
  IElementType USE = new VHDLTokenType("use");
  IElementType VARIABLE = new VHDLTokenType("variable");
  IElementType VERTICAL_BAR = new VHDLTokenType("|");
  IElementType WAIT = new VHDLTokenType("wait");
  IElementType WHEN = new VHDLTokenType("when");
  IElementType WHILE = new VHDLTokenType("while");
  IElementType WITH = new VHDLTokenType("with");
  IElementType XNOR = new VHDLTokenType("xnor");
  IElementType XOR = new VHDLTokenType("xor");

  class Factory {
    public static PsiElement createElement(ASTNode node) {
      IElementType type = node.getElementType();
      if (type == ABSTRACT_LITERAL) {
        return new VHDLAbstractLiteralImpl(node);
      }
      else if (type == ACCESS_TYPE_DEFINITION) {
        return new VHDLAccessTypeDefinitionImpl(node);
      }
      else if (type == ACTUAL_DESIGNATOR) {
        return new VHDLActualDesignatorImpl(node);
      }
      else if (type == ACTUAL_PARAMETER_PART) {
        return new VHDLActualParameterPartImpl(node);
      }
      else if (type == ACTUAL_PART) {
        return new VHDLActualPartImpl(node);
      }
      else if (type == ADDING_OPERATOR) {
        return new VHDLAddingOperatorImpl(node);
      }
      else if (type == AGGREGATE) {
        return new VHDLAggregateImpl(node);
      }
      else if (type == ALIAS_DECLARATION) {
        return new VHDLAliasDeclarationImpl(node);
      }
      else if (type == ALIAS_DESIGNATOR) {
        return new VHDLAliasDesignatorImpl(node);
      }
      else if (type == ALLOCATOR) {
        return new VHDLAllocatorImpl(node);
      }
      else if (type == ARCHITECTURE_BODY) {
        return new VHDLArchitectureBodyImpl(node);
      }
      else if (type == ARCHITECTURE_DECLARATIVE_PART) {
        return new VHDLArchitectureDeclarativePartImpl(node);
      }
      else if (type == ARCHITECTURE_STATEMENT_PART) {
        return new VHDLArchitectureStatementPartImpl(node);
      }
      else if (type == ARRAY_TYPE_DEFINITION) {
        return new VHDLArrayTypeDefinitionImpl(node);
      }
      else if (type == ASSERTION) {
        return new VHDLAssertionImpl(node);
      }
      else if (type == ASSERTION_STATEMENT) {
        return new VHDLAssertionStatementImpl(node);
      }
      else if (type == ASSOCIATION_ELEMENT) {
        return new VHDLAssociationElementImpl(node);
      }
      else if (type == ASSOCIATION_LIST) {
        return new VHDLAssociationListImpl(node);
      }
      else if (type == ATTRIBUTE_DECLARATION) {
        return new VHDLAttributeDeclarationImpl(node);
      }
      else if (type == ATTRIBUTE_DESIGNATOR) {
        return new VHDLAttributeDesignatorImpl(node);
      }
      else if (type == ATTRIBUTE_NAME) {
        return new VHDLAttributeNameImpl(node);
      }
      else if (type == ATTRIBUTE_NAME_) {
        return new VHDLAttributeName_Impl(node);
      }
      else if (type == ATTRIBUTE_SPECIFICATION) {
        return new VHDLAttributeSpecificationImpl(node);
      }
      else if (type == BINDING_INDICATION) {
        return new VHDLBindingIndicationImpl(node);
      }
      else if (type == BLOCK_CONFIGURATION) {
        return new VHDLBlockConfigurationImpl(node);
      }
      else if (type == BLOCK_DECLARATIVE_ITEM) {
        return new VHDLBlockDeclarativeItemImpl(node);
      }
      else if (type == BLOCK_DECLARATIVE_PART) {
        return new VHDLBlockDeclarativePartImpl(node);
      }
      else if (type == BLOCK_HEADER) {
        return new VHDLBlockHeaderImpl(node);
      }
      else if (type == BLOCK_SPECIFICATION) {
        return new VHDLBlockSpecificationImpl(node);
      }
      else if (type == BLOCK_STATEMENT) {
        return new VHDLBlockStatementImpl(node);
      }
      else if (type == BLOCK_STATEMENT_PART) {
        return new VHDLBlockStatementPartImpl(node);
      }
      else if (type == CASE_STATEMENT) {
        return new VHDLCaseStatementImpl(node);
      }
      else if (type == CASE_STATEMENT_ALTERNATIVE) {
        return new VHDLCaseStatementAlternativeImpl(node);
      }
      else if (type == CHOICE) {
        return new VHDLChoiceImpl(node);
      }
      else if (type == CHOICES) {
        return new VHDLChoicesImpl(node);
      }
      else if (type == COMPONENT_CONFIGURATION) {
        return new VHDLComponentConfigurationImpl(node);
      }
      else if (type == COMPONENT_DECLARATION) {
        return new VHDLComponentDeclarationImpl(node);
      }
      else if (type == COMPONENT_INSTANTIATION_STATEMENT) {
        return new VHDLComponentInstantiationStatementImpl(node);
      }
      else if (type == COMPONENT_SPECIFICATION) {
        return new VHDLComponentSpecificationImpl(node);
      }
      else if (type == COMPOSITE_TYPE_DEFINITION) {
        return new VHDLCompositeTypeDefinitionImpl(node);
      }
      else if (type == CONCURRENT_ASSERTION_STATEMENT) {
        return new VHDLConcurrentAssertionStatementImpl(node);
      }
      else if (type == CONCURRENT_PROCEDURE_CALL_STATEMENT) {
        return new VHDLConcurrentProcedureCallStatementImpl(node);
      }
      else if (type == CONCURRENT_SIGNAL_ASSIGNMENT_STATEMENT) {
        return new VHDLConcurrentSignalAssignmentStatementImpl(node);
      }
      else if (type == CONCURRENT_STATEMENT) {
        return new VHDLConcurrentStatementImpl(node);
      }
      else if (type == CONDITION) {
        return new VHDLConditionImpl(node);
      }
      else if (type == CONDITIONAL_SIGNAL_ASSIGNMENT) {
        return new VHDLConditionalSignalAssignmentImpl(node);
      }
      else if (type == CONDITIONAL_WAVEFORMS) {
        return new VHDLConditionalWaveformsImpl(node);
      }
      else if (type == CONDITION_CLAUSE) {
        return new VHDLConditionClauseImpl(node);
      }
      else if (type == CONFIGURATION_DECLARATION) {
        return new VHDLConfigurationDeclarationImpl(node);
      }
      else if (type == CONFIGURATION_DECLARATIVE_ITEM) {
        return new VHDLConfigurationDeclarativeItemImpl(node);
      }
      else if (type == CONFIGURATION_DECLARATIVE_PART) {
        return new VHDLConfigurationDeclarativePartImpl(node);
      }
      else if (type == CONFIGURATION_ITEM) {
        return new VHDLConfigurationItemImpl(node);
      }
      else if (type == CONFIGURATION_SPECIFICATION) {
        return new VHDLConfigurationSpecificationImpl(node);
      }
      else if (type == CONSTANT_DECLARATION) {
        return new VHDLConstantDeclarationImpl(node);
      }
      else if (type == CONSTRAINED_ARRAY_DEFINITION) {
        return new VHDLConstrainedArrayDefinitionImpl(node);
      }
      else if (type == CONSTRAINT) {
        return new VHDLConstraintImpl(node);
      }
      else if (type == CONTEXT_CLAUSE) {
        return new VHDLContextClauseImpl(node);
      }
      else if (type == CONTEXT_ITEM) {
        return new VHDLContextItemImpl(node);
      }
      else if (type == DELAY_MECHANISM) {
        return new VHDLDelayMechanismImpl(node);
      }
      else if (type == DESIGNATOR) {
        return new VHDLDesignatorImpl(node);
      }
      else if (type == DESIGN_UNIT) {
        return new VHDLDesignUnitImpl(node);
      }
      else if (type == DIRECTION) {
        return new VHDLDirectionImpl(node);
      }
      else if (type == DISCONNECTION_SPECIFICATION) {
        return new VHDLDisconnectionSpecificationImpl(node);
      }
      else if (type == DISCRETE_RANGE) {
        return new VHDLDiscreteRangeImpl(node);
      }
      else if (type == ELEMENT_ASSOCIATION) {
        return new VHDLElementAssociationImpl(node);
      }
      else if (type == ELEMENT_DECLARATION) {
        return new VHDLElementDeclarationImpl(node);
      }
      else if (type == ELEMENT_SUBTYPE_DEFINITION) {
        return new VHDLElementSubtypeDefinitionImpl(node);
      }
      else if (type == ENCODED_STRING_LITERAL) {
        return new VHDLEncodedStringLiteralImpl(node);
      }
      else if (type == ENTITY_ASPECT) {
        return new VHDLEntityAspectImpl(node);
      }
      else if (type == ENTITY_CLASS) {
        return new VHDLEntityClassImpl(node);
      }
      else if (type == ENTITY_CLASS_ENTRY) {
        return new VHDLEntityClassEntryImpl(node);
      }
      else if (type == ENTITY_CLASS_ENTRY_LIST) {
        return new VHDLEntityClassEntryListImpl(node);
      }
      else if (type == ENTITY_DECLARATION) {
        return new VHDLEntityDeclarationImpl(node);
      }
      else if (type == ENTITY_DECLARATIVE_ITEM) {
        return new VHDLEntityDeclarativeItemImpl(node);
      }
      else if (type == ENTITY_DECLARATIVE_PART) {
        return new VHDLEntityDeclarativePartImpl(node);
      }
      else if (type == ENTITY_DESIGNATOR) {
        return new VHDLEntityDesignatorImpl(node);
      }
      else if (type == ENTITY_HEADER) {
        return new VHDLEntityHeaderImpl(node);
      }
      else if (type == ENTITY_NAME_LIST) {
        return new VHDLEntityNameListImpl(node);
      }
      else if (type == ENTITY_SPECIFICATION) {
        return new VHDLEntitySpecificationImpl(node);
      }
      else if (type == ENTITY_STATEMENT) {
        return new VHDLEntityStatementImpl(node);
      }
      else if (type == ENTITY_STATEMENT_PART) {
        return new VHDLEntityStatementPartImpl(node);
      }
      else if (type == ENTITY_TAG) {
        return new VHDLEntityTagImpl(node);
      }
      else if (type == ENUMERATION_LITERAL) {
        return new VHDLEnumerationLiteralImpl(node);
      }
      else if (type == ENUMERATION_TYPE_DEFINITION) {
        return new VHDLEnumerationTypeDefinitionImpl(node);
      }
      else if (type == EXIT_STATEMENT) {
        return new VHDLExitStatementImpl(node);
      }
      else if (type == EXPRESSION) {
        return new VHDLExpressionImpl(node);
      }
      else if (type == FACTOR) {
        return new VHDLFactorImpl(node);
      }
      else if (type == FILE_DECLARATION) {
        return new VHDLFileDeclarationImpl(node);
      }
      else if (type == FILE_LOGICAL_NAME) {
        return new VHDLFileLogicalNameImpl(node);
      }
      else if (type == FILE_OPEN_INFORMATION) {
        return new VHDLFileOpenInformationImpl(node);
      }
      else if (type == FILE_TYPE_DEFINITION) {
        return new VHDLFileTypeDefinitionImpl(node);
      }
      else if (type == FLOATING_TYPE_DEFINITION) {
        return new VHDLFloatingTypeDefinitionImpl(node);
      }
      else if (type == FORMAL_DESIGNATOR) {
        return new VHDLFormalDesignatorImpl(node);
      }
      else if (type == FORMAL_PARAMETER_LIST) {
        return new VHDLFormalParameterListImpl(node);
      }
      else if (type == FORMAL_PART) {
        return new VHDLFormalPartImpl(node);
      }
      else if (type == FULL_TYPE_DECLARATION) {
        return new VHDLFullTypeDeclarationImpl(node);
      }
      else if (type == FUNCTION_CALL) {
        return new VHDLFunctionCallImpl(node);
      }
      else if (type == FUNCTION_CALL_PARAMETER) {
        return new VHDLFunctionCallParameterImpl(node);
      }
      else if (type == GENERATE_STATEMENT) {
        return new VHDLGenerateStatementImpl(node);
      }
      else if (type == GENERATION_SCHEME) {
        return new VHDLGenerationSchemeImpl(node);
      }
      else if (type == GENERIC_CLAUSE) {
        return new VHDLGenericClauseImpl(node);
      }
      else if (type == GENERIC_LIST) {
        return new VHDLGenericListImpl(node);
      }
      else if (type == GENERIC_MAP_ASPECT) {
        return new VHDLGenericMapAspectImpl(node);
      }
      else if (type == GROUP_CONSTITUENT) {
        return new VHDLGroupConstituentImpl(node);
      }
      else if (type == GROUP_CONSTITUENT_LIST) {
        return new VHDLGroupConstituentListImpl(node);
      }
      else if (type == GROUP_DECLARATION) {
        return new VHDLGroupDeclarationImpl(node);
      }
      else if (type == GROUP_TEMPLATE_DECLARATION) {
        return new VHDLGroupTemplateDeclarationImpl(node);
      }
      else if (type == GUARDED_SIGNAL_SPECIFICATION) {
        return new VHDLGuardedSignalSpecificationImpl(node);
      }
      else if (type == IDENTIFIER) {
        return new VHDLIdentifierImpl(node);
      }
      else if (type == IDENTIFIER_LIST) {
        return new VHDLIdentifierListImpl(node);
      }
      else if (type == IF_STATEMENT) {
        return new VHDLIfStatementImpl(node);
      }
      else if (type == INCOMPLETE_TYPE_DECLARATION) {
        return new VHDLIncompleteTypeDeclarationImpl(node);
      }
      else if (type == INDEXED_NAME) {
        return new VHDLIndexedNameImpl(node);
      }
      else if (type == INDEXED_NAME_FUNCTION_CALL) {
        return new VHDLIndexedNameFunctionCallImpl(node);
      }
      else if (type == INDEX_CONSTRAINT) {
        return new VHDLIndexConstraintImpl(node);
      }
      else if (type == INDEX_SPECIFICATION) {
        return new VHDLIndexSpecificationImpl(node);
      }
      else if (type == INDEX_SUBTYPE_DEFINITION) {
        return new VHDLIndexSubtypeDefinitionImpl(node);
      }
      else if (type == INSTANTIATED_UNIT) {
        return new VHDLInstantiatedUnitImpl(node);
      }
      else if (type == INSTANTIATION_LIST) {
        return new VHDLInstantiationListImpl(node);
      }
      else if (type == INTEGER_TYPE_DEFINITION) {
        return new VHDLIntegerTypeDefinitionImpl(node);
      }
      else if (type == INTERFACE_CONSTANT_DECLARATION) {
        return new VHDLInterfaceConstantDeclarationImpl(node);
      }
      else if (type == INTERFACE_DECLARATION) {
        return new VHDLInterfaceDeclarationImpl(node);
      }
      else if (type == INTERFACE_ELEMENT) {
        return new VHDLInterfaceElementImpl(node);
      }
      else if (type == INTERFACE_FILE_DECLARATION) {
        return new VHDLInterfaceFileDeclarationImpl(node);
      }
      else if (type == INTERFACE_LIST) {
        return new VHDLInterfaceListImpl(node);
      }
      else if (type == INTERFACE_SIGNAL_DECLARATION) {
        return new VHDLInterfaceSignalDeclarationImpl(node);
      }
      else if (type == INTERFACE_VARIABLE_DECLARATION) {
        return new VHDLInterfaceVariableDeclarationImpl(node);
      }
      else if (type == ITERATION_SCHEME) {
        return new VHDLIterationSchemeImpl(node);
      }
      else if (type == LABEL_) {
        return new VHDLLabel_Impl(node);
      }
      else if (type == LIBRARY_CLAUSE) {
        return new VHDLLibraryClauseImpl(node);
      }
      else if (type == LIBRARY_UNIT) {
        return new VHDLLibraryUnitImpl(node);
      }
      else if (type == LITERAL_) {
        return new VHDLLiteral_Impl(node);
      }
      else if (type == LOGICAL_NAME) {
        return new VHDLLogicalNameImpl(node);
      }
      else if (type == LOGICAL_NAME_LIST) {
        return new VHDLLogicalNameListImpl(node);
      }
      else if (type == LOOP_STATEMENT) {
        return new VHDLLoopStatementImpl(node);
      }
      else if (type == MODE) {
        return new VHDLModeImpl(node);
      }
      else if (type == MULTIPLYING_OPERATOR) {
        return new VHDLMultiplyingOperatorImpl(node);
      }
      else if (type == NEXT_STATEMENT) {
        return new VHDLNextStatementImpl(node);
      }
      else if (type == NULL_STATEMENT) {
        return new VHDLNullStatementImpl(node);
      }
      else if (type == NUMERIC_LITERAL) {
        return new VHDLNumericLiteralImpl(node);
      }
      else if (type == OPERATOR_SYMBOL) {
        return new VHDLOperatorSymbolImpl(node);
      }
      else if (type == OPTIONS) {
        return new VHDLOptionsImpl(node);
      }
      else if (type == PACKAGE_BODY) {
        return new VHDLPackageBodyImpl(node);
      }
      else if (type == PACKAGE_BODY_DECLARATIVE_ITEM) {
        return new VHDLPackageBodyDeclarativeItemImpl(node);
      }
      else if (type == PACKAGE_BODY_DECLARATIVE_PART) {
        return new VHDLPackageBodyDeclarativePartImpl(node);
      }
      else if (type == PACKAGE_DECLARATION) {
        return new VHDLPackageDeclarationImpl(node);
      }
      else if (type == PACKAGE_DECLARATIVE_ITEM) {
        return new VHDLPackageDeclarativeItemImpl(node);
      }
      else if (type == PACKAGE_DECLARATIVE_PART) {
        return new VHDLPackageDeclarativePartImpl(node);
      }
      else if (type == PARAMETER_SPECIFICATION) {
        return new VHDLParameterSpecificationImpl(node);
      }
      else if (type == PHYSICAL_LITERAL) {
        return new VHDLPhysicalLiteralImpl(node);
      }
      else if (type == PHYSICAL_TYPE_DEFINITION) {
        return new VHDLPhysicalTypeDefinitionImpl(node);
      }
      else if (type == PORT_CLAUSE) {
        return new VHDLPortClauseImpl(node);
      }
      else if (type == PORT_LIST) {
        return new VHDLPortListImpl(node);
      }
      else if (type == PORT_MAP_ASPECT) {
        return new VHDLPortMapAspectImpl(node);
      }
      else if (type == PRIMARY) {
        return new VHDLPrimaryImpl(node);
      }
      else if (type == PRIMARY_UNIT) {
        return new VHDLPrimaryUnitImpl(node);
      }
      else if (type == PRIMARY_UNIT_DECLARATION) {
        return new VHDLPrimaryUnitDeclarationImpl(node);
      }
      else if (type == PROCEDURE_CALL) {
        return new VHDLProcedureCallImpl(node);
      }
      else if (type == PROCEDURE_CALL_STATEMENT) {
        return new VHDLProcedureCallStatementImpl(node);
      }
      else if (type == PROCESS_DECLARATIVE_ITEM) {
        return new VHDLProcessDeclarativeItemImpl(node);
      }
      else if (type == PROCESS_DECLARATIVE_PART) {
        return new VHDLProcessDeclarativePartImpl(node);
      }
      else if (type == PROCESS_STATEMENT) {
        return new VHDLProcessStatementImpl(node);
      }
      else if (type == PROCESS_STATEMENT_PART) {
        return new VHDLProcessStatementPartImpl(node);
      }
      else if (type == QUALIFIED_EXPRESSION) {
        return new VHDLQualifiedExpressionImpl(node);
      }
      else if (type == RANGE_) {
        return new VHDLRange_Impl(node);
      }
      else if (type == RANGE_CONSTRAINT) {
        return new VHDLRangeConstraintImpl(node);
      }
      else if (type == RECORD_TYPE_DEFINITION) {
        return new VHDLRecordTypeDefinitionImpl(node);
      }
      else if (type == RELATION) {
        return new VHDLRelationImpl(node);
      }
      else if (type == RELATIONAL_OPERATOR) {
        return new VHDLRelationalOperatorImpl(node);
      }
      else if (type == REPORT_STATEMENT) {
        return new VHDLReportStatementImpl(node);
      }
      else if (type == RETURN_STATEMENT) {
        return new VHDLReturnStatementImpl(node);
      }
      else if (type == SCALAR_TYPE_DEFINITION) {
        return new VHDLScalarTypeDefinitionImpl(node);
      }
      else if (type == SECONDARY_UNIT) {
        return new VHDLSecondaryUnitImpl(node);
      }
      else if (type == SECONDARY_UNIT_DECLARATION) {
        return new VHDLSecondaryUnitDeclarationImpl(node);
      }
      else if (type == SELECTED_NAME) {
        return new VHDLSelectedNameImpl(node);
      }
      else if (type == SELECTED_SIGNAL_ASSIGNMENT) {
        return new VHDLSelectedSignalAssignmentImpl(node);
      }
      else if (type == SELECTED_WAVEFORMS) {
        return new VHDLSelectedWaveformsImpl(node);
      }
      else if (type == SENSITIVITY_CLAUSE) {
        return new VHDLSensitivityClauseImpl(node);
      }
      else if (type == SENSITIVITY_LIST) {
        return new VHDLSensitivityListImpl(node);
      }
      else if (type == SEQUENCE_OF_STATEMENTS) {
        return new VHDLSequenceOfStatementsImpl(node);
      }
      else if (type == SEQUENTIAL_STATEMENT) {
        return new VHDLSequentialStatementImpl(node);
      }
      else if (type == SHIFT_EXPRESSION) {
        return new VHDLShiftExpressionImpl(node);
      }
      else if (type == SHIFT_OPERATOR) {
        return new VHDLShiftOperatorImpl(node);
      }
      else if (type == SIGN) {
        return new VHDLSignImpl(node);
      }
      else if (type == SIGNAL_ASSIGNMENT_STATEMENT) {
        return new VHDLSignalAssignmentStatementImpl(node);
      }
      else if (type == SIGNAL_DECLARATION) {
        return new VHDLSignalDeclarationImpl(node);
      }
      else if (type == SIGNAL_KIND) {
        return new VHDLSignalKindImpl(node);
      }
      else if (type == SIGNAL_LIST) {
        return new VHDLSignalListImpl(node);
      }
      else if (type == SIGNATURE) {
        return new VHDLSignatureImpl(node);
      }
      else if (type == SIMPLE_EXPRESSION) {
        return new VHDLSimpleExpressionImpl(node);
      }
      else if (type == SIMPLE_NAME) {
        return new VHDLSimpleNameImpl(node);
      }
      else if (type == SLICE_NAME) {
        return new VHDLSliceNameImpl(node);
      }
      else if (type == SLICE_NAME_FUNCTION_CALL) {
        return new VHDLSliceNameFunctionCallImpl(node);
      }
      else if (type == SUBPROGRAM_BODY) {
        return new VHDLSubprogramBodyImpl(node);
      }
      else if (type == SUBPROGRAM_DECLARATION) {
        return new VHDLSubprogramDeclarationImpl(node);
      }
      else if (type == SUBPROGRAM_DECLARATIVE_ITEM) {
        return new VHDLSubprogramDeclarativeItemImpl(node);
      }
      else if (type == SUBPROGRAM_DECLARATIVE_PART) {
        return new VHDLSubprogramDeclarativePartImpl(node);
      }
      else if (type == SUBPROGRAM_KIND) {
        return new VHDLSubprogramKindImpl(node);
      }
      else if (type == SUBPROGRAM_SPECIFICATION) {
        return new VHDLSubprogramSpecificationImpl(node);
      }
      else if (type == SUBPROGRAM_STATEMENT_PART) {
        return new VHDLSubprogramStatementPartImpl(node);
      }
      else if (type == SUBTYPE_DECLARATION) {
        return new VHDLSubtypeDeclarationImpl(node);
      }
      else if (type == SUBTYPE_INDICATION) {
        return new VHDLSubtypeIndicationImpl(node);
      }
      else if (type == SUFFIX) {
        return new VHDLSuffixImpl(node);
      }
      else if (type == TARGET) {
        return new VHDLTargetImpl(node);
      }
      else if (type == TERM) {
        return new VHDLTermImpl(node);
      }
      else if (type == TIMEOUT_CLAUSE) {
        return new VHDLTimeoutClauseImpl(node);
      }
      else if (type == TYPE_CONVERSION) {
        return new VHDLTypeConversionImpl(node);
      }
      else if (type == TYPE_DECLARATION) {
        return new VHDLTypeDeclarationImpl(node);
      }
      else if (type == TYPE_DEFINITION) {
        return new VHDLTypeDefinitionImpl(node);
      }
      else if (type == TYPE_MARK) {
        return new VHDLTypeMarkImpl(node);
      }
      else if (type == UNCONSTRAINED_ARRAY_DEFINITION) {
        return new VHDLUnconstrainedArrayDefinitionImpl(node);
      }
      else if (type == USE_CLAUSE) {
        return new VHDLUseClauseImpl(node);
      }
      else if (type == VARIABLE_ASSIGNMENT_STATEMENT) {
        return new VHDLVariableAssignmentStatementImpl(node);
      }
      else if (type == VARIABLE_DECLARATION) {
        return new VHDLVariableDeclarationImpl(node);
      }
      else if (type == WAIT_STATEMENT) {
        return new VHDLWaitStatementImpl(node);
      }
      else if (type == WAVEFORM) {
        return new VHDLWaveformImpl(node);
      }
      else if (type == WAVEFORM_ELEMENT) {
        return new VHDLWaveformElementImpl(node);
      }
      throw new AssertionError("Unknown element type: " + type);
    }
  }
}
